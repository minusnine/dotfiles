package main

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"os"
	"syscall"
	"unsafe"
)

// The SCSI Generic I/O ioctl number.
const sgIO = 0x2285

type transferDirection int32

const (
	txNone      transferDirection = -1
	txToDev                       = -2
	txFromDev                     = -3
	txToFromDev                   = -4
	txUnknown                     = -5
)

/*
type bite struct {
	bits byte
}

func (b *bite) Capacity() int  { return 8 }
func (b *bite) Set(i int)      { b.bits |= 1 << byte(i) }
func (b *bite) Unset(i int)    { b.bits &^= 1 << byte(i) }
func (b *bite) Get(i int) bool { return b.bits&(1<<byte(i)) != 0 }
*/

type sgWireInquiry struct {
	OpCode   byte
	Options  byte
	PageCode byte
	_        byte // reserved
	Length   byte
	_        byte // reserved
}

func (s *sgWireInquiry) Bytes() []byte {
	s.OpCode = byte(0x12)
	var buf bytes.Buffer
	err := binary.Write(&buf, binary.LittleEndian, s)
	if err != nil {
		panic(err)
	}
	return buf.Bytes()
}

type sgWireHeader struct {
	InterfaceID   int32
	Direction     transferDirection
	CmdLength     byte
	SenseLength   byte
	IOVecCount    uint16
	DataLength    uint32
	DataPtr       uint64
	CmdPtr        uint64
	SensePtr      uint64
	Timeout       uint32
	Flags         uint32
	PackID        int32
	UsrPtr        uint64
	Status        byte
	MaskedStatus  byte
	MsgStatus     byte
	SenseWriteLen byte
	HostStatus    int16
	DriverStatus  int16
	Resid         int32
	Duration      uint32
	Info          uint32
}

func (s *sgWireHeader) SetCmdBuf(b []byte) {
	s.CmdPtr = (uint64)(uintptr(unsafe.Pointer(&b[0])))
	s.CmdLength = byte(len(b))
}

func (s *sgWireHeader) SetDataBuf(b []byte) {
	s.DataPtr = (uint64)(uintptr(unsafe.Pointer(&b[0])))
	s.DataLength = uint32(len(b))
}

func (s *sgWireHeader) SetSenseBuf(b []byte) {
	s.SensePtr = (uint64)(uintptr(unsafe.Pointer(&b[0])))
	s.SenseLength = byte(len(b))
}

func (s *sgWireHeader) Bytes() []byte {
	s.InterfaceID = int32('S')
	var buf bytes.Buffer
	err := binary.Write(&buf, binary.LittleEndian, s)
	if err != nil {
		panic(err)
	}
	return buf.Bytes()
}

func (s *sgWireHeader) String() string {
	var buf bytes.Buffer
	for i, b := range s.Bytes() {
		buf.WriteString(fmt.Sprintf("%.2x ", b))
		if (i+1)%16 == 0 {
			buf.WriteString("\n")
		}
	}
	return buf.String()
}

type Proxy struct {
	DevicePath string
}

//func (s *Proxy) Inquiry(rpc *rpc.Call, req *pb.InquiryRequest, resp *pb.InquiryResponse) error {
func main() {
	b := sgWireHeader{
		Direction: txFromDev,
		Timeout:   60000,
	}
	cmd := sgWireInquiry{
		Length: 36,
	}
	b.SetCmdBuf(cmd.Bytes())

	sense := make([]byte, 32)
	b.SetSenseBuf(sense)

	data := make([]byte, 36)
	b.SetDataBuf(data)

	buf := b.Bytes()
	f, err := os.OpenFile("/dev/sg0", os.O_RDWR, 0)
	if err != nil {
		panic(err)
	}
	fmt.Printf("% x", buf)
	_, _, errno := syscall.Syscall(syscall.SYS_IOCTL, f.Fd(), uintptr(sgIO), uintptr(unsafe.Pointer(&buf[0])))
	if errno != 0 {
		fmt.Printf("Errno: %d\n", errno)
	}

	fmt.Printf("\n\n\n% x\n", data)
	fmt.Printf("\n\n\n% s\n", data[8:16])
	fmt.Printf("\n\n\n% s\n", data[16:31])
	fmt.Printf("\n\n\n% s\n", data[32:36])
	fmt.Printf("\n\n\n% s\n", data[36:56])
	fmt.Printf("\n\n\n% x\n", sense)
	fmt.Printf("\n\n\n% x\n", cmd)
}
